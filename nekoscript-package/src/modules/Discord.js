/**
 * Module Discord.neko
 * Ce module permet d'utiliser l'API Discord.js directement avec nekoScript
 */

"use strict";

const discord = require('discord.js');
const { GatewayIntentBits, Partials, ActivityType, EmbedBuilder, AttachmentBuilder } = discord;

/**
 * Cr√©e un module Discord pour nekoScript avec acc√®s complet √† Discord.js
 * @returns {Map} Module exposant les fonctionnalit√©s Discord
 */
function createDiscordModule() {
  const discordModule = new Map();
  
  // Fonction pour cr√©er un client Discord
  discordModule.set('cr√©erBot', (token, options = {}) => {
    if (!token || token === "VOTRE_TOKEN_DISCORD") {
      console.warn("[NekoScript] ‚ö†Ô∏è Aucun token Discord valide n'a √©t√© fourni!");
      console.warn("[NekoScript] ‚ÑπÔ∏è Pour obtenir un token, cr√©ez une application sur https://discord.com/developers/applications");
      // On continue quand m√™me avec un client Discord fonctionnel, mais il ne pourra pas se connecter
    }
    
    // Options par d√©faut pour la cr√©ation du client
    const defaultOptions = {
      // Intents par d√©faut
      intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.GuildMembers,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.DirectMessages,
        GatewayIntentBits.GuildVoiceStates,
        GatewayIntentBits.GuildPresences,
        GatewayIntentBits.GuildMessageReactions
      ],
      // Partials par d√©faut
      partials: [
        Partials.Message,
        Partials.Channel,
        Partials.Reaction,
        Partials.User,
        Partials.GuildMember
      ],
      // Autres options
      autoLoginIfValid: true, // Se connecter automatiquement si token valide
      showReadyMessage: true  // Afficher un message quand le bot est pr√™t
    };
    
    // Fusionner les options par d√©faut avec celles fournies
    const botOptions = { ...defaultOptions, ...options };
    
    // Configuration compl√®te du client Discord.js
    const client = new discord.Client({
      intents: botOptions.intents,
      partials: botOptions.partials,
      // Autres options de Discord.js
      rest: { 
        timeout: 60000 // Augmenter le timeout pour les API Discord √† 60s
      }
    });
    
    // Propri√©t√©s suppl√©mentaires pour faciliter l'utilisation
    client.nekoOptions = botOptions;
    client.readyTimestamp = null;
    
    // √âv√©nement ready
    client.once('ready', () => {
      client.readyTimestamp = Date.now();
      
      if (botOptions.showReadyMessage) {
        console.log(`üê± Bot Discord connect√© en tant que ${client.user.tag}!`);
        console.log(`üìä Connect√© √† ${client.guilds.cache.size} serveurs`);
        console.log(`üìÖ Date de connexion: ${new Date().toLocaleString()}`);
      }
      
      // √âv√©nement personnalis√© pour les d√©veloppeurs nekoScript
      client.emit('botReady', client);
    });
    
    // G√©rer les erreurs de connexion
    client.on('error', (error) => {
      console.error("[NekoScript] ‚ùå Erreur Discord.js:", error.message);
    });
    
    // G√©rer les d√©connexions
    client.on('disconnect', (event) => {
      console.warn("[NekoScript] ‚ö†Ô∏è Bot d√©connect√©! Code:", event.code);
      console.warn("[NekoScript] Raison:", event.reason);
    });
    
    // G√©rer les reconnexions
    client.on('reconnecting', () => {
      console.log("[NekoScript] üîÑ Tentative de reconnexion...");
    });
    
    // M√©thodes suppl√©mentaires pour faciliter l'utilisation
    client.estConnect√© = () => client.readyTimestamp !== null;
    
    client.obtenirServeur = (serveurId) => {
      return client.guilds.cache.get(serveurId);
    };
    
    client.obtenirUtilisateur = async (userId) => {
      try {
        return await client.users.fetch(userId);
      } catch (error) {
        console.error(`[NekoScript] Erreur lors de la r√©cup√©ration de l'utilisateur ${userId}:`, error.message);
        return null;
      }
    };
    
    // Se connecter automatiquement si demand√© et token valide
    if (botOptions.autoLoginIfValid && token && token !== "VOTRE_TOKEN_DISCORD") {
      try {
        client.login(token).catch(err => {
          console.error("[NekoScript] ‚ùå Erreur de connexion Discord:", err.message);
          if (err.message.includes("token")) {
            console.error("[NekoScript] ‚ÑπÔ∏è V√©rifiez que votre token Discord est valide.");
          }
        });
      } catch (error) {
        console.error("[NekoScript] ‚ùå Erreur lors de la tentative de connexion:", error.message);
      }
    }
    
    return client;
  });
  
  // Fonction pour surveiller les messages
  discordModule.set('surMessage', (client, callback) => {
    if (typeof client === 'string') {
      // Si on a donn√© un token directement au lieu d'un client
      console.warn("[NekoScript] ‚ö†Ô∏è Attention: 'surMessage' a re√ßu un token au lieu d'un client bot. Cr√©ation automatique du client...");
      
      // Cr√©er automatiquement un client avec ce token
      const newClient = new discord.Client({
        intents: [
          GatewayIntentBits.Guilds,
          GatewayIntentBits.GuildMessages,
          GatewayIntentBits.MessageContent,
          GatewayIntentBits.DirectMessages
        ]
      });
      
      // Se connecter avec le token
      newClient.login(client).catch(err => {
        console.error("[NekoScript] ‚ùå Erreur de connexion Discord:", err.message);
      });
      
      // Remplacer le client par le vrai client
      client = newClient;
    }
    
    // V√©rifier que le client est bien un objet Client de Discord.js
    if (!client || typeof client.on !== 'function') {
      throw new Error("[NekoScript] Le client Discord fourni n'est pas valide. Utilisez 'cr√©erBot(token)' pour obtenir un client valide.");
    }
    
    // V√©rifier que le client a les intents n√©cessaires
    const requiredIntents = [
      GatewayIntentBits.Guilds,
      GatewayIntentBits.GuildMessages,
      GatewayIntentBits.MessageContent
    ];
    
    // Ajouter un √©v√©nement pour √©couter les messages
    client.on('messageCreate', async (message) => {
      try {
        // Log pour d√©bogage
        console.log(`[NekoScript] üì® Message re√ßu de ${message.author.username}: ${message.content}`);
        
        // Conversion au format nekoScript avec des m√©thodes am√©lior√©es
        const messageNeko = {
          // Propri√©t√©s de base
          contenu: message.content,
          auteur: message.author.username,
          auteurId: message.author.id,
          canalId: message.channelId,
          serveurId: message.guildId,
          date: message.createdAt,
          estBot: message.author.bot,
          mentions: message.mentions,
          
          // M√©thodes pour r√©pondre - prend en charge les cha√Ænes, les objets et les embeds
          r√©pondre: async (contenu) => {
            console.log(`[NekoScript] üì§ R√©ponse envoy√©e: ${typeof contenu === 'string' ? contenu : '[Objet/Embed]'}`);
            
            try {
              // Format adapt√© selon le type
              if (typeof contenu === 'string') {
                return await message.reply(contenu);
              } else if (contenu && typeof contenu === 'object') {
                // Si c'est un embed ou une configuration complexe
                return await message.reply(contenu);
              } else {
                return await message.reply({ content: String(contenu) });
              }
            } catch (error) {
              console.error(`[NekoScript] ‚ùå Erreur lors de l'envoi de la r√©ponse:`, error);
              throw new Error(`Impossible d'envoyer la r√©ponse: ${error.message}`);
            }
          },
          
          // R√©agir avec un √©moji
          r√©agir: async (emoji) => {
            try {
              console.log(`[NekoScript] üé≠ R√©action ajout√©e: ${emoji}`);
              return await message.react(emoji);
            } catch (error) {
              console.error(`[NekoScript] ‚ùå Erreur lors de l'ajout de la r√©action:`, error);
              throw new Error(`Impossible d'ajouter la r√©action: ${error.message}`);
            }
          },
          
          // Supprimer le message
          supprimer: async () => {
            try {
              console.log(`[NekoScript] üóëÔ∏è Message supprim√©`);
              return await message.delete();
            } catch (error) {
              console.error(`[NekoScript] ‚ùå Erreur lors de la suppression du message:`, error);
              throw new Error(`Impossible de supprimer le message: ${error.message}`);
            }
          },
          
          // Envoi direct dans le canal (sans r√©pondre)
          envoyerCanal: async (contenu) => {
            try {
              console.log(`[NekoScript] üì§ Message envoy√© au canal`);
              return await message.channel.send(contenu);
            } catch (error) {
              console.error(`[NekoScript] ‚ùå Erreur lors de l'envoi au canal:`, error);
              throw new Error(`Impossible d'envoyer au canal: ${error.message}`);
            }
          },
          
          // M√©thodes utilitaires
          getMembre: () => message.member,
          getCanal: () => message.channel,
          getServeur: () => message.guild,
          
          // Obtenir des informations sur l'auteur
          getAuteurInfo: () => ({
            nom: message.author.username,
            id: message.author.id,
            tag: message.author.tag,
            avatar: message.author.displayAvatarURL(),
            bot: message.author.bot
          })
        };
        
        // Appel du callback utilisateur avec le message format√© pour nekoScript
        await Promise.resolve(callback(messageNeko));
      } catch (err) {
        console.error("[NekoScript] ‚ùå Erreur lors du traitement du message:", err);
      }
    });
    
    console.log("[NekoScript] ‚úÖ Gestionnaire de messages configur√©");
    return client; // Retourner le client pour permettre le cha√Ænage
  });
  
  // Fonction pour envoyer un message dans un canal
  discordModule.set('envoyerMessage', (client, canalId, message) => {
    const channel = client.channels.cache.get(canalId);
    if (channel) {
      return channel.send(message);
    } else {
      throw new Error(`Canal avec ID ${canalId} introuvable.`);
    }
  });
  
  // Fonction pour cr√©er un embed riche
  discordModule.set('cr√©erEmbed', (titre, description, couleur, image) => {
    const embed = new EmbedBuilder()
      .setTitle(titre || '')
      .setDescription(description || '')
      .setColor(couleur || '#8c52ff');
      
    if (image) {
      embed.setImage(image);
    }
    
    return embed;
  });
  
  // Fonction pour configurer le statut du bot
  discordModule.set('changerStatut', (client, type, nom) => {
    // Log pour d√©bogage
    console.log(`[NekoScript] Changement du statut du bot: ${type} ${nom}`);
    
    const types = {
      'joue': ActivityType.Playing,
      'regarde': ActivityType.Watching,
      '√©coute': ActivityType.Listening,
      'streaming': ActivityType.Streaming,
      'comp√©tition': ActivityType.Competing
    };
    
    try {
      // V√©rifier que le client est bien connect√©
      if (!client || !client.user) {
        console.error('[NekoScript] ‚ùå Erreur: impossible de changer le statut, bot non connect√©');
        return false;
      }
      
      // Appliquer le statut personnalis√©
      const activityType = types[type] || ActivityType.Playing;
      
      client.user.setPresence({
        activities: [{
          name: nom,
          type: activityType
        }],
        status: 'online'
      });
      
      console.log(`[NekoScript] ‚úÖ Statut du bot modifi√© avec succ√®s: ${type} ${nom}`);
      return true;
    } catch (error) {
      console.error(`[NekoScript] ‚ùå Erreur lors du changement de statut: ${error.message}`);
      return false;
    }
  });
  
  // Fonction pour obtenir les membres d'un serveur
  discordModule.set('obtenirMembres', async (client, serveurId) => {
    const guild = client.guilds.cache.get(serveurId);
    if (!guild) {
      throw new Error(`Serveur avec ID ${serveurId} introuvable.`);
    }
    
    // R√©cup√©rer tous les membres
    await guild.members.fetch();
    
    return Array.from(guild.members.cache.values()).map(member => ({
      id: member.id,
      nom: member.user.username,
      estBot: member.user.bot,
      r√¥les: Array.from(member.roles.cache.values()).map(role => role.name),
      avatar: member.user.displayAvatarURL(),
      aJoint: member.joinedAt
    }));
  });
  
  // Fonction pour envoyer un message priv√©
  discordModule.set('envoyerMessagePriv√©', async (client, userId, message) => {
    try {
      const user = await client.users.fetch(userId);
      const dm = await user.createDM();
      return dm.send(message);
    } catch (error) {
      throw new Error(`Impossible d'envoyer un message priv√©: ${error.message}`);
    }
  });
  
  // Fonction pour cr√©er un syst√®me de commandes
  discordModule.set('cr√©erGestionnaireCommandes', (pr√©fixe) => {
    const commandes = new Map();
    
    // Fonction pour ajouter une commande
    const ajouterCommande = (nom, description, callback) => {
      commandes.set(nom, { description, callback });
    };
    
    // Fonction pour traiter les messages
    const traiter = (message) => {
      // V√©rifier si le message commence par le pr√©fixe
      if (!message.contenu.startsWith(pr√©fixe)) return false;
      
      // Extraire le nom de la commande et les arguments
      const args = message.contenu.slice(pr√©fixe.length).trim().split(/ +/);
      const commandName = args.shift().toLowerCase();
      
      // V√©rifier si la commande existe
      if (!commandes.has(commandName)) return false;
      
      // Ex√©cuter la commande
      try {
        commandes.get(commandName).callback(message, args);
        return true;
      } catch (error) {
        console.error(`Erreur lors de l'ex√©cution de la commande ${commandName}:`, error);
        return false;
      }
    };
    
    return {
      ajouterCommande,
      traiter,
      commandes
    };
  });
  
  // Fonction pour cr√©er des commandes slash (interactions)
  discordModule.set('cr√©erCommandesSlash', (client, commandes) => {
    if (!client || !client.application) {
      throw new Error("[NekoScript] Client Discord non valide ou non connect√©. Connectez-vous d'abord.");
    }
    
    const { REST } = require('discord.js');
    const { Routes } = require('discord-api-types/v10');
    
    // Construire les donn√©es des commandes
    const commandesData = [];
    for (const [nom, options] of Object.entries(commandes)) {
      const commandData = {
        name: nom,
        description: options.description || `Commande ${nom}`,
        options: options.options || []
      };
      
      commandesData.push(commandData);
    }
    
    // Cr√©er un client REST pour enregistrer les commandes
    const rest = new REST({ version: '10' }).setToken(client.token);
    
    // Enregistrer les commandes globalement
    (async () => {
      try {
        console.log(`[NekoScript] Enregistrement de ${commandesData.length} commandes slash...`);
        
        await rest.put(
          Routes.applicationCommands(client.application.id),
          { body: commandesData }
        );
        
        console.log('[NekoScript] ‚úÖ Commandes slash enregistr√©es avec succ√®s!');
        
        // Configurer l'√©couteur d'interactions
        client.on('interactionCreate', async (interaction) => {
          if (!interaction.isCommand()) return;
          
          const { commandName } = interaction;
          
          if (commandes[commandName] && commandes[commandName].ex√©cuter) {
            try {
              await commandes[commandName].ex√©cuter(interaction);
            } catch (error) {
              console.error(`[NekoScript] Erreur lors de l'ex√©cution de la commande slash ${commandName}:`, error);
              
              // R√©pondre avec une erreur si la r√©ponse n'a pas d√©j√† √©t√© envoy√©e
              if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({ 
                  content: "Une erreur s'est produite lors de l'ex√©cution de cette commande.", 
                  ephemeral: true 
                });
              }
            }
          }
        });
      } catch (error) {
        console.error('[NekoScript] ‚ùå Erreur lors de l\'enregistrement des commandes slash:', error);
      }
    })();
  });
  
  // Fonction pour r√©agir aux √©v√©nements Discord
  discordModule.set('sur√âv√©nement', (client, √©v√©nement, callback) => {
    if (!client || typeof client.on !== 'function') {
      throw new Error("[NekoScript] Client Discord non valide. Utilisez cr√©erBot(token) pour obtenir un client valide.");
    }
    
    // Mapper les noms d'√©v√©nements fran√ßais vers les noms d'√©v√©nements Discord.js
    const √©v√©nementsMap = {
      'pr√™t': 'ready',
      'messageRe√ßu': 'messageCreate',
      'r√©action': 'messageReactionAdd',
      'membre': 'guildMemberAdd',
      'membreParti': 'guildMemberRemove',
      'interaction': 'interactionCreate',
      'erreur': 'error',
      'warning': 'warn'
    };
    
    // Obtenir le nom d'√©v√©nement Discord.js correspondant ou utiliser l'original
    const √©v√©nementDiscord = √©v√©nementsMap[√©v√©nement] || √©v√©nement;
    
    // √âcouter l'√©v√©nement
    client.on(√©v√©nementDiscord, (...args) => {
      try {
        // Appeler le callback avec les arguments
        callback(...args);
      } catch (error) {
        console.error(`[NekoScript] Erreur dans le gestionnaire d'√©v√©nement '${√©v√©nement}':`, error);
      }
    });
    
    return client; // Pour le cha√Ænage
  });
  
  // Fonction pour g√©rer des boutons interactifs
  discordModule.set('cr√©erBouton', (id, label, style = 'primary', emoji = null, disabled = false) => {
    const { ButtonBuilder, ButtonStyle } = require('discord.js');
    
    // Mapper les styles en fran√ßais vers les styles Discord.js
    const styles = {
      'primaire': ButtonStyle.Primary,
      'secondaire': ButtonStyle.Secondary,
      'succ√®s': ButtonStyle.Success,
      'danger': ButtonStyle.Danger,
      'lien': ButtonStyle.Link,
      
      // √âquivalents en anglais
      'primary': ButtonStyle.Primary,
      'secondary': ButtonStyle.Secondary,
      'success': ButtonStyle.Success,
      'danger': ButtonStyle.Danger,
      'link': ButtonStyle.Link
    };
    
    // Cr√©er le bouton
    const bouton = new ButtonBuilder()
      .setCustomId(id)
      .setLabel(label)
      .setStyle(styles[style] || ButtonStyle.Primary);
    
    if (emoji) {
      bouton.setEmoji(emoji);
    }
    
    if (disabled) {
      bouton.setDisabled(true);
    }
    
    return bouton;
  });
  
  // Fonction pour cr√©er un menu select
  discordModule.set('cr√©erMenu', (id, options, placeholder = "S√©lectionnez une option", minValues = 1, maxValues = 1) => {
    const { StringSelectMenuBuilder } = require('discord.js');
    
    // Cr√©er le menu
    const menu = new StringSelectMenuBuilder()
      .setCustomId(id)
      .setPlaceholder(placeholder)
      .setMinValues(minValues)
      .setMaxValues(maxValues);
    
    // Ajouter les options
    for (const option of options) {
      menu.addOptions({
        label: option.label,
        value: option.value,
        description: option.description || undefined,
        emoji: option.emoji || undefined,
        default: option.d√©faut || false
      });
    }
    
    return menu;
  });
  
  // Fonction pour cr√©er une action ligne (pour les boutons/menus)
  discordModule.set('cr√©erLigneAction', (composants) => {
    const { ActionRowBuilder } = require('discord.js');
    
    // Cr√©er une ligne d'action avec les composants
    return new ActionRowBuilder().addComponents(composants);
  });
  
  // Exposer les constantes Discord.js
  discordModule.set('Couleurs', {
    ROUGE: '#ff0000',
    VERT: '#00ff00',
    BLEU: '#0000ff',
    JAUNE: '#ffff00',
    CYAN: '#00ffff',
    MAGENTA: '#ff00ff',
    BLANC: '#ffffff',
    NOIR: '#000000',
    ROSE: '#ff69b4',
    ORANGE: '#ffa500',
    VIOLET: '#8a2be2',
    NEKO: '#8c52ff'
  });
  
  // Exposer les constantes de permissions
  discordModule.set('Permissions', {
    ADMINISTRATEUR: 'Administrator',
    G√âRER_SERVEUR: 'ManageGuild',
    G√âRER_MESSAGES: 'ManageMessages',
    G√âRER_R√îLES: 'ManageRoles',
    BANNIR_MEMBRES: 'BanMembers',
    EXPULSER_MEMBRES: 'KickMembers',
    ENVOYER_MESSAGES: 'SendMessages',
    VOIR_SALONS: 'ViewChannel',
    PARLER: 'Speak'
  });
  
  return discordModule;
}

module.exports = { createDiscordModule };